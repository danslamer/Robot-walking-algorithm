//所需变量，全为全局变量

//代表异常标志
uint8_t YC_sp_Flag;//上坡
uint8_t YC_xp_Flag;//下坡
uint8_t YC_zst_Flag;//左踩石头
uint8_t YC_yst_Flag;//右踩石头

//代表足部状态,0代表悬空，1代表接地
uint8_t zb_zt[12]={0};

//各类动作组,n不定，动作组后续完善
uint16 pos_sp[N][MOTOR_NUM]={ {1000,1500,1500,1500,1500,1500,1500,1500,1500},

					 {1000,1500,1500,1500,1500,1500,1500,1500,1500}
};	 //一连串动作,上坡
uint16 pos_gp[N][MOTOR_NUM]={ {1000,1500,1500,1500,1500,1500,1500,1500,1500},

					 {1000,1500,1500,1500,1500,1500,1500,1500,1500}
};	 //一连串动作,下坡
uint16 pos_z[N][MOTOR_NUM]={ {1000,1500,1500,1500,1500,1500,1500,1500,1500},

};	 //一连串动作,左踩石头
uint16 pos_y[N][MOTOR_NUM]={ {1000,1500,1500,1500,1500,1500,1500,1500,1500},

};	 //一连串动作,右踩石头


//判断函数，调用足部扫描函数，根据zb_zt值判断
void robot_YcPanduan(void){
  000000000000
  010001001000
  111001100100
  //非这几个状态则为异常
  //非正常行走状态，判定为异常
  //判断为哪种异常，相关异常状态标志加一
  //写在定时器里，50ms判断一次,一次异常相关状态+1
  //当某个异常状态数值达到4时，进入异常处理函数
}


//足部扫描函数,加电路设计
void zbScan(void) {
  //扫描GPIO口电平，修改zb_zt的值
  /* code */
}


//王
//异常处理函数
void sp(uint16 *pos) {
  //输入动作组指针
  //一行行执行动作组，直到‘\0’
  //调用Flip_GPIO_One
  /* code */
}
